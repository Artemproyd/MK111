## Лексемы:
- **Имена (переменные), числа, `=` (присваивание)**
- **Скобки:** `(`, `)`, `[`, `]`, `{`, `}`
- **Одиночные символы:** `/`, `*`, `+`, `-`, `~`
- **Операторы сравнения:** `<`, `>`, `==`
- **Логические операции:** `|`, `&`, `!`
- **Специальные:** `;`, `//`
- **Служебные слова:** `int`, `arr`, `if`, `else`, `while`, `read`, `print`
## Таблица переходов автомата:
### Состояния:
- `S` — начальное
- `A` — идентификаторы
- `B` — числа
- `C` — `=` или `==`
- `D` — `/` или `//`
- `M` — ошибка
- `E` — конечное
### Таблица
| Сост. | буква | цифра | /    | \*   | +    | \-   | ~    | <    | \>   | \=   | \|   | &    | !    | ;    | (    | )    | [    | ]    | {    | }    | пробел | \\n  | др.  | EOF  |
| ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- | ---- |
| S     | A/0   | B/1   | D    | E/5  | E/6  | E/7  | E/8  | E/9  | E/10 | С    | E/19 | E/20 | E/21 | E/12 | E/13 | E/14 | E/15 | E/16 | E/17 | E/18 | S/23   | S/22 | M/24 | E/25 |
| A     | A/26  | A/26  | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27 | E/27   | E/27 | M/24 | E/27 |
| B     | M/24  | B/28  | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29 | E/29   | E/29 | M/24 | E/29 |
| С     | E/2   | E/2   | E/2  | E/2  | E/2  | E/2  | E/2  | E/2  | E/2  | E/11 | E/2  | E/2  | E/2  | E/2  | E/2  | E/2  | E/2  | E/2  | E/2  | E/2  | E/2    | E/2  | E/2  | E/2  |
| D     | E/4   | E/4   | F    | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4  | E/4    | E/4  | E/4  | E/4  |
| F     | F/30  | F/30  | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30 | F/30   | E/22 | F/30 | E/25 |
### Семантические программы
| №   | Описание                   |
| --- | -------------------------- |
| 0   | Начало идентификатора      |
| 1   | Начало числа               |
| 2   | Присваивание `=`           |
| 4   | Оператор `/`               |
| 5   | Оператор `*`               |
| 6   | Оператор `+`               |
| 7   | Оператор `-`               |
| 8   | Оператор `~`               |
| 9   | Оператор `<`               |
| 10  | Оператор `>`               |
| 11  | Оператор `==`              |
| 12  | Символ `;`                 |
| 13  | Символ `(`                 |
| 14  | Символ `)`                 |
| 15  | Символ `[`                 |
| 16  | Символ `]`                 |
| 17  | Символ `{`                 |
| 18  | Символ `}`                 |
| 19  | Логический оператор `      |
| 20  | Логический оператор `&`    |
| 21  | Логический оператор `!`    |
| 22  | Переход на новую строку    |
| 23  | Пропуск пробела            |
| 24  | Ошибка: не символ языка    |
| 25  | Конец файла                |
| 26  | Продолжение идентификатора |
| 27  | Завершение идентификатора  |
| 28  | Продолжение числа          |
| 29  | Завершение числа           |
| 30  | Комментарий                |
### КС-грамматика
```
Программа → int ID ДекларацияInt Программа
          | ID ИспользованиеInt Программа
          | if ( ЛогическоеВыражение ) { Программа } Альтернатива Программа
          | while ( ЛогическоеВыражение ) { Программа } Программа
          | read ( ID ) ; Программа
          | print ( ЛогическоеВыражение ) ; Программа
          | ε

ДекларацияInt → ; Программа
              | = АрифмВыражение ; Программа
              | [ Выражение ] ; Программа
              | [ Выражение ] = { Инициализаторы } ; Программа

ИнициализацияМассива → = { Инициализаторы }
                      | ε

ИспользованиеInt → = АрифмВыражение ; Программа
                  | [ АрифмВыражение ] = АрифмВыражение ; Программа

Альтернатива → else { Программа }
              | ε

Инициализаторы → АрифмВыражение ИнициализаторыПрод
                | ε

ИнициализаторыПрод → , АрифмВыражение ИнициализаторыПрод
                    | ε

АрифмВыражение → Слагаемое АрифмПрод

АрифмПрод → + Слагаемое АрифмПрод
           | - Слагаемое АрифмПрод
           | ε

Слагаемое → Множитель СлагПрод

СлагПрод → * Множитель СлагПрод
          | / Множитель СлагПрод
          | ε

Множитель → ПервичноеАрифм
           | ~ ПервичноеАрифм

ПервичноеАрифм → ID ХвостИндекса
                | NUMBER
                | ( АрифмВыражение )

ХвостИндекса → [ АрифмВыражение ]
              | ε

```
### КС-грамматика в нестрогой форме Грейбах
```
Программа → int ID ДекларацияInt
          | ID ИспользованиеInt
          | if ( ЛогическоеВыражение ) { Программа } Альтернатива Программа
          | while ( ЛогическоеВыражение ) { Программа } Программа
          | read ( ID ) ; Программа
          | print ( ЛогическоеВыражение ) ; Программа
          | ε

ДекларацияInt → ; Программа
	          | = Выражение ; Программа
              | [ Выражение ] ХвостДекларацияInt

ХвостДекларацияInt → ; Программа |
					 = { Инициализаторы } ; Программа

ИспользованиеInt → = Выражение ; Программа
		         | [ Выражение ] = Выражение ; Программа

Альтернатива → else { Программа }
          | ε

Инициализаторы → ID ИнициализаторыПрод

ИнициализаторыПрод → , ID ИнициализаторыПрод
                   | ε

Выражение → ID СложПрод
          | ID [ Выражение ] СложПрод
          | ( Выражение ) СложПрод
          | ~ Выражение СложПрод

СложПрод → + Выражение СложПрод
          | - Выражение СложПрод
          | ε

ЛогВыраж → ! ЛогВыраж ЛогИ_Прод ЛогИЛИ_Прод
         | ( ЛогВыраж ) ЛогИ_Прод ЛогИЛИ_Прод
         | ПервичноеАрифм ХвостСравнения ЛогИ_Прод ЛогИЛИ_Прод

ЛогИ_Прод → & ЛогВыраж ЛогИ_Прод
          | ε

ЛогИЛИ_Прод → | ЛогВыраж ЛогИЛИ_Прод
             | ε

ХвостСравнения → > АрифмВыраж
               | < АрифмВыраж
               | == АрифмВыраж
               | ε

ПервичноеАрифм → ID ХвостИндекса
               | NUMBER
               | ( АрифмВыраж )
               | ~ АрифмВыраж

ХвостИндекса → [ АрифмВыраж ]
             | ε

ЛогическоеВыражение → ID ЛогСравн
                    | ID [ Выражение ] ЛогСравн
                    | ( Выражение ) ЛогСравн
                    | ~ Выражение ЛогСравн
                    | ! ЛогическоеВыражение ЛогОпПрод
                    | ( ЛогическоеВыражение ) ЛогОпПрод

ЛогСравн → > Выражение ЛогОпПрод
         | < Выражение ЛогОпПрод
         | == Выражение ЛогОпПрод

ЛогОпПрод → & ЛогическоеВыражение ЛогОпПрод
          | | ЛогическоеВыражение ЛогОпПрод
          | ε

```
### Список операций ОПС

**Арифметические бинарные:**
- `+` — сложение    
- `-` — вычитание    
- `*` — умножение    
- `/` — деление    
- `=` — присваивание    
**Сравнения:**
- `>` — больше  
- `<` — меньше    
- `==` — равно    
**Логические бинарные:**
- `|` — логическое ИЛИ    
- `&` — логическое И    
**Унарные:**
- `~` — унарный минус
- `!` — логическое НЕ    
**Ввод-вывод:**
- `w` — вывести значение
- `r` — считать значение
**Операции с массивами:**
- alloc_array — выделить массив
- array_read — считать в элемент массива
- array_get — получить элемент массива
- array_set — установить элемент массива
**Управляющие переходы:**
- `j` — безусловный переход
- `jf` — переход по ложному условию

**Метки (числа в ОПС)**
- используются как адреса переходов
### Семантические действия
**Обозначения:**
- `a` — записать переменную    
- `k` — записать константу    
- `+`, `-`, `*`, `/`, `=`, `>`, `<`, `==`, `|`, `&`, `!`, `~` — записать операцию    
- alloc_array — записать выделение массива.
- array_read — записать ввод в элемент массива.
- array_get — записать получение элемента массива.
- array_set — записать установку элемента массива.
- `w` — записать оператор вывода    
- `r` — записать оператор ввода

**Специальные программы (работа с метками и переходами):**

| №   | Действие                                                                                                                                                                                                                                                                               |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | Для if: Записать операцию `jf` с пустым операндом, сохранить текущую позицию в списке OPS в стеке меток (`push_label_ops_stack`).                                                                                                                                                      |
| 2   | Для if: Установить операнд операции `jf` из стека меток на позицию после блока if (`set_jump_target`), записать операцию `j` с пустым операндом, сохранить текущую позицию в стеке меток, затем установить операнд `j` на начало блока else или конец конструкции (`set_jump_target`). |
| 3   | Для if без else: Установить операнд операции `jf` из стека меток на текущую позицию в списке OPS (`set_jump_target`).                                                                                                                                                                  |
| 4   | Для while: Сохранить текущую позицию в списке OPS (начало цикла) в стеке меток (`push_label_ops_stack`) перед обработкой логического выражения.                                                                                                                                        |
| 5   | Для while: Установить операнд операции `jf` из стека меток на позицию после цикла (`set_jump_target`), записать операцию `j` на позицию начала цикла (сохранённую в стеке меток).                                                                                                      |


**Примечания:**
- Пустая операция `""` используется в `Parser::add_ops_instruction("", id)` или `Parser::add_ops_instruction("", number)` для добавления переменных и чисел в список OPS.
- `Parser::set_jump_target(label_pos, target)` обновляет операнд операции `j` или `jf` на значение `target`.
- `Parser::push_label_ops_stack(pos)` и `Parser::pop_label_ops_stack()` управляют стеком меток для конструкций `if` и `while`.